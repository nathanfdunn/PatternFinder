package tests;

import behaviorClassification.ChunkList;
import behaviorClassification.ClassifiedChunkList;
import behaviorClassification.CsvToTable;
import behaviorClassification.InputSimulator;
import behaviorClassification.KnnModel;
import behaviorClassification.ManualInputReader;
import behaviorClassification.ModelClassifier;
import behaviorClassification.RawTimeSeriesTable;
import behaviorClassification.Serializer;
import behaviorClassification.UserClassifier;

public class ClassifierTrainingTest {

	public static void main(String[] args){
		
	}
	
	public static ModelClassifier getStandardModel(){
		return (ModelClassifier)Serializer.deserialize("GISP2_ModelClassifier");
	}
	
	
	private static ChunkList getGispData(){
		RawTimeSeriesTable gispData = CsvToTable.readCsv("../../DataSets_R/nfdunn_GISP2.csv");
		return new ChunkList(gispData, 100);
	}
	
	
	private static ModelClassifier trainManually(){
		ClassifiedChunkList chunks = new UserClassifier( 
				new ManualInputReader() ).classify( getGispData() );
		
		return new ModelClassifier( new KnnModel(chunks) );
	}
	
	private static ClassifiedChunkList classifyManually(){
		return new UserClassifier( new ManualInputReader() )
			.classify( getGispData() );
	}
	
	private static ClassifiedChunkList classifyAutomatically(){
		return new UserClassifier( new InputSimulator() )
			.classify( getGispData() );
	}
	
	private static void overwriteModel( ModelClassifier classifier ){
		Serializer.serialize(classifier, "GISP2_ModelClassifier");
	}
	
	
	
	
	

//
//	RawDataTable rdt = CsvToTable.readCsv("../../DataSets_R/nfdunn_Moulton1.csv");
//	ChunkList cl = new ChunkList(rdt, 30);
//	ClassifiedChunkList ccl = new UserClassifier(
//			new ManualInputReader()
//			//new InputSimulator()
//	).classify(cl);
//
//	FeatureTable table = new FeatureTable(ccl, new StandardFeatureExtractor());
//	KnnModel model = new KnnModel(table);
//	
////	Pnt.pnt(table);
////	Pnt.pnt(table.getScaledTable());
////	table.shuffle();
//	Pnt.pnt(table);
//
//	model = new KnnModel(table);
//	Pnt.pnt(model.evaluateAccuracy());
//	//int i=1/0;
//	
//	FeatureExtractor fe = new StandardFeatureExtractor();
//	for (String q : cl.getQuantities()){
//		for (Chunk c : cl.getChunks(q)){
//			if (FeatureExtractor.isFeaturizable(c)){
//				double[] vec = fe.extractFeatures(c);
//				Pnt.pnt(model.classify(vec));
//			}
//		}
//	}
//	
//	//Pnt.pnt(model);
//	
	
}

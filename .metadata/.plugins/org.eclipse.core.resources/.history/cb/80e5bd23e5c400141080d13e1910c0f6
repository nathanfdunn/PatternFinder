package behaviorClassification;

import java.io.BufferedReader;
import java.io.FileReader;
import java.util.ArrayList;

/**
 * 
 * @author nathandunn
 * Fills a table with the raw information from a CSV.
 */
public class CsvToTable {

	//TODO Note: restrictions on how the time data is organized (earliest to latest, etc.)
	
	//TODO Note CSV must have a header line
	public static RawDataTable readCsv(String fileName){
		String[][] contents = readAll(fileName);
		
		String[] headers = contents[0];
		
		double[][] transposedEntries = new double[contents.length-1][];
		for (int i=1; i<contents.length; i++){
			transposedEntries[i-1] = parseLine(contents[i]);
		}
		double[][] entries = MyMath.transpose(transposedEntries);
		
		int timeInd = findTimeInd(entries);
		
		return new RawDataTable(entries, headers, timeInd);
	}
	
	private static int findTimeInd(double[][] entries){
		//Find which column is "most" sorted
		return entries.length-1;		//Assume it's the last column
	}
	
	
//	public static RawDataTable readCsv(String fileName, int timeInd){
//		
//	}
//	
//	public static RawDataTable readCsv(String fileName, String timeHeader){
//		
//	}
	
	private static double[] parseLine(String[] line){
		double[] out = new double[line.length];
		try {
			for (int i=0; i<out.length; i++)
				out[i] = Double.parseDouble(line[i]);
		} catch (Exception e){
			e.printStackTrace();
		}
		return out;
	}
	
	private static String[][] readAll(String fileName){
		ArrayList<String[]> contents = new ArrayList<String[]>();
		try{
			BufferedReader br = new BufferedReader(new FileReader(fileName));
			String line;
			while ((line = br.readLine()) != null) {
				contents.add(line.split(","));
			}
			br.close();
		}catch (Exception e){
			e.printStackTrace();
		}
		return contents.toArray(new String[contents.size()][]);
	}
	
//	private static boolean isHeader(String[] line){
//		if (line.length > 0){
//			try {
//				Double.parseDouble(line[0]);
//				return false;
//			} catch (Exception e){
//				return true;
//			}
//		}else{
//			return false;
//		}
//	}
	
	
}

package behaviorClassification;

import java.util.ArrayList;
import java.util.Arrays;



public class UserClassifier {

	/**
	 * Strips out the NaN values
	 * @param chunk
	 * @return
	 */
	private static Chunk cleanChunk(Chunk c){
		ArrayList<Double> outTimes = new ArrayList<Double>();
		ArrayList<Double> outVals = new ArrayList<Double>();
		
		double[] times = c.getTimes();
		double[] vals = c.getVals();
		
		for (int i=0; i<times.length; i++){
			if (!Double.isNaN(times[i]) && !Double.isNaN(vals[i])){
				outTimes.add(times[i]);
				outVals.add(vals[i]);
			}
		}
		
		double[] outTimes2 = new double[outTimes.size()];
		double[] outVals2 = new double[outVals.size()];
		MyMath.checkDim(outTimes2, outVals2);
		for (int i=0; i<outTimes2.length; i++){
			outTimes2[i] = outTimes.get(i);
			outVals2[i] = outVals.get(i);
		}
		
		return new Chunk( outVals2, outTimes2, c.getStart(), c.getEnd() );
	}

	//private static boolean
	
	public static ClassifiedChunkList classify(ChunkList chunkList){
		//TODO control which quantities to classify?
		ClassifiedChunkList out = new ClassifiedChunkList();
		
		for (String quantity : chunkList.getQuantities()){
			ArrayList<ClassifiedChunk> list = 
					classify(chunkList.getChunks(quantity));
			out.addList(quantity, list);
		}
		
		return out;
	}
	
	
	public static ArrayList<ClassifiedChunk> classify(ArrayList<Chunk> chunks){
		ArrayList<ClassifiedChunk> list = new ArrayList<ClassifiedChunk>();
		
		
		
//		boolean go = true;
//		while (go){
//			
//		}
		System.out.println("Not implemented yet");
		int crash = 1/0;
		return list;
	}
	
	
	
//	private ClassifiedChunk classify( Chunk chunk ){
//		String classification = getClassification(chunk);
//		return new ClassifiedChunk(chunk, classification);
//	}
//	
//	
	private String getClassification(Chunk chunk){
		return "None";
	}
	
	private static String[] temp = new String[]{
		"q", "back",
	};
	private static ArrayList<String> controlSequences = 
			new ArrayList<String>( Arrays.asList(temp) );
}
